#!/usr/bin/ash
# vim: filetype=sh

## funcs:
oops() {
		echo "Error occured, continuing in 1s..."
		sleep 1
}

fatal() {
		echo "FATAL Error occured! $*"
		echo" press ENTER to reboot"
		read
		reboot -f
}

mount_squash() {
		# Mount squash (base RO filesystem)
		E_MSG="$SQUASHROOT not found in $DISKLABEL !"
		mount -o loop -t squashfs "$F_BOOT_ROOT/$SQUASHROOT" "$R" || fatal "$E_MSG"
		[ -n "$DEBUG" ] && echo "- squash image loaded"
}

load_kmap() {
		if [ -e "$R/usr/share/kbd/keymaps/initrd.map" ]; then
			loadkmap < "$R/usr/share/kbd/keymaps/initrd.map" || oops
			[ -n "$DEBUG" ] && echo "- keymap"
		fi
}

run_newroot() {
		PATH="$R/bin:$PATH" LD_LIBRARY_PATH="$R/lib" $*
}

process_mountname() {
		NAME="$1"
		if [ -z "$2" ]; then
				P="$F_PFX"
				WP="$F_WPFX"
		else
				P="$F_TMPFS_ROOT"
				WP="$F_TMPFS_WORK_ROOT"
		fi
		FLAT_NAME=$(echo $1 | sed 's#/#_#g')
		FLAT_NAME=${FLAT_NAME:1}
		if [ ! -d "$P/$FLAT_NAME" ]; then
			mkdir -p "$P/$FLAT_NAME"
		fi
		if [ ! -d "$WP/$FLAT_NAME" ]; then
			mkdir -p "$WP/$FLAT_NAME"
		fi
		echo $FLAT_NAME
}

run_latehook() {
	R="/new_root" # just a shortcut

	if [ -z "$SQUASHROOT" ] ; then
		SQUASHROOT={{ROOTIMAGE}}
	fi
	if [ -z "$DISKLABEL" ] ; then
		DISKLABEL={{DISKLABEL}}
	fi
	STORAGE_IMAGE={{STORAGE}}

	COMPRESSOR={{COMPRESSOR}}
	F_RWPART="$R{{STORAGE_PATH}}"
	F_BOOT_ROOT="/fat_root" # original root, includes squashfs image
	F_TMPFS_ROOT="/run/overlay/ROOT" # rootdirs prefix for tmpfs overlay
	F_TMPFS_WORK_ROOT="/run/overlay/WORK" # workdirs prefix for tmpfs overlay
	F_PFX="$F_RWPART/ROOT" # new roots prefix
	F_WPFX="$F_RWPART/WORK" # new work prefix
	DEBUG=$shell

	## main code:

	mkdir "$F_BOOT_ROOT"
	"$mount_handler" $F_BOOT_ROOT # Mount boot device
	mount_squash # Mount SQUASH in /
	load_kmap # loading kmap from it
	mount --move "$F_BOOT_ROOT" "$R/boot" || oops # make original root accessible as /boot (ro)
	rmdir "$F_BOOT_ROOT" # now it's moved, we can remove original mountpoint

    # Allow initial RW folder: run
	mount -t tmpfs tmpfs "$R/run"

	# default mount types
	STORED=0
	DEV="/dev/disk/by-label/${DISKLABEL}-RW"

	# check persistant
	if [ -z "$nobtr" ] && [ -e "$DEV" ] ; then # We have a storage device, Yey !!
	    echo "[STORED]"
	    run_newroot btrfs check -p --repair --check-data-csum "$DEV" > "/tmp/btrfs_check.log" 2>&1 && FS_OPTS="ssd,compress=lzo,discard,relatime"
	    run_newroot fsck.ext4 -p "$DEV" > "/tmp/ext4_check.log" 2>&1 && FS_OPTS="discard,relatime"

	    mount "$DEV" "$F_RWPART" -o $FS_OPTS || oops

	    mv /tmp/*.log "$F_RWPART"

	    [ -n "$FS_OPTS" ] && [ "$?" -eq "0" ] && STORED=1
	else
	    echo "[VOLATILE]"
	    mount -t tmpfs tmpfs "$F_RWPART"
			if [ "$COMPRESSOR" = "gzip" ] ; then
				CCAT="gzcat"
			else
				CCAT="xzcat"
			fi
			#run_newroot $CCAT  | run_newroot tar xf - -C "$F_RWPART"
			run_newroot tar xf "$R/boot/rootfs.default" -C "$F_RWPART"
	fi

	for d in home var_lib_pacman etc opt srv usr var_db; do
	    mkdir -p "$F_PFX/$d"
	    mkdir -p "$F_WPFX/$d"
	done

	for d in mnt var_lib; do
	    mkdir -p "$R/$F_TMPFS_ROOT/$d"
	    mkdir -p "$R/$F_TMPFS_WORK_ROOT/$d"
	done

  REAL_LABEL=$(cat /proc/cmdline)
	REAL_LABEL=${REAL_LABEL#*root=}
	REAL_LABEL=${REAL_LABEL% *}
	# mount /usr to make systemd happy
	mount -t overlay "/dev/disk/by-label/${REAL_LABEL#*=}" "$R/usr" -o "relatime,lowerdir=$R/usr,upperdir=$R/storage/ROOT/usr,workdir=$R/storage/WORK/usr"

	# generate fstab
	T_F="/new_root/run/fstab"
	cat > /tmp/fstab <<EOF
/dev/loop0      /               squashfs ro,x-systemd.device-timeout=90,relatime        0 0
BOOTDEVICE      /boot           vfat     ro,x-systemd.device-timeout=90,relatime,fmask=0022,dmask=0022,shortname=mixed,errors=remount-ro        0 1
#BOOTDEVICE-RW  /storage        ext4     rw,nofail,x-systemd.device-timeout=1,relatime,discard,data=ordered     0 1

/storage/ROOT/home    /home     none     rw,x-systemd.device-timeout=60,relatime,discard,data=ordered,bind      0 2

BOOTDEVICE     /mnt             overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/mnt,upperdir=/run/overlay/ROOT/mnt,workdir=/run/overlay/WORK/mnt     0 2
BOOTDEVICE     /var/lib         overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/var/lib,upperdir=/run/overlay/ROOT/var_lib,workdir=/run/overlay/WORK/var_lib 0 2
BOOTDEVICE     /etc             overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/etc,upperdir=/storage/ROOT/etc,workdir=/storage/WORK/etc     0 2
BOOTDEVICE     /opt             overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/opt,upperdir=/storage/ROOT/opt,workdir=/storage/WORK/opt     0 2
BOOTDEVICE     /srv             overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/srv,upperdir=/storage/ROOT/srv,workdir=/storage/WORK/srv     0 2
BOOTDEVICE     /usr             overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/usr,upperdir=/storage/ROOT/usr,workdir=/storage/WORK/usr     0 2
BOOTDEVICE     /var/db          overlay  rw,x-systemd.device-timeout=10,relatime,lowerdir=/var/db,upperdir=/storage/ROOT/var_db,workdir=/storage/WORK/var_db    0 2
tmpfs          /var/log        tmpfs    rw     0 2
tmpfs          /var/tmp        tmpfs    rw     0 2
tmpfs          /var/cache      tmpfs    rw     0 2
EOF

sed "s#BOOTDEVICE#${REAL_LABEL}#" /tmp/fstab > $T_F

	#ln -s "/dev/disk/by-label/${DISKLABEL}" BOOTDEVICE

	[ -n "$shell" ] && run_newroot sh -i # start a shell if requested
}

